// package main provides the functionality for the ssg (aka: schema struct generation) command.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
)

func main() {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, os.Getenv("GOFILE"), nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	genLine, err := strconv.Atoi(os.Getenv("GOLINE"))
	if err != nil {
		log.Fatal("couldn't parse $GOLINE:", err)
	}

	var targetType string
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok != token.TYPE {
				return true
			}
			if fset.Position(x.Pos()).Line != genLine+1 {
				return true
			}
			for _, spec := range x.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					if _, ok := ts.Type.(*ast.StructType); !ok {
						log.Fatalf("%s is not a struct type", ts.Name.Name)
					}
					targetType = ts.Name.Name
					return false
				}
			}
		}
		return true
	})

	if targetType == "" {
		log.Fatal("no struct type found after //go:generate directive")
	}

	generateWrappedStruct(node, targetType)
}

func generateWrappedStruct(node *ast.File, targetType string) {
	fmt.Printf("// Code generated by go generate; DO NOT EDIT.\n\n")
	fmt.Printf("package %s\n\n", node.Name.Name)

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if x.Name.Name == targetType {
				if st, ok := x.Type.(*ast.StructType); ok {
					fmt.Printf("type %sSchema struct {\n", targetType)
					for _, field := range st.Fields.List {
						typeExpr := exprToString(field.Type)
						for _, name := range field.Names {
							fmt.Printf("\t%s Wrapper[%s]", name.Name, typeExpr)
							if field.Tag != nil {
								fmt.Printf(" %s", field.Tag.Value)
							}
							fmt.Printf("\n")
						}
					}
					fmt.Printf("}\n")
				}
			}
		}
		return true
	})
}

func exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return exprToString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + exprToString(t.Elt)
		}
		return fmt.Sprintf("[%s]%s", exprToString(t.Len), exprToString(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", exprToString(t.Key), exprToString(t.Value))
	default:
		return fmt.Sprintf("%#v", expr)
	}
}
