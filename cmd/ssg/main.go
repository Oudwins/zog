// package main provides the functionality for the ssg (aka: schema struct generation) command.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
	"text/template"
)

type GeneratorOutput struct {
	PackageName string
	StructName  string
	Fields      []Field
}

type Field struct {
	Name string
	Type string
	Tags *string
}

var tmpl *template.Template = template.Must(template.New("gen").Parse(`
// Code generated by zog ssg; DO NOT EDIT.

package {{.Package}}

type {{.TypeName}} struct {
	{{-range $field := .Fields}}
	{{$field.Name}} {{$field.Type}}{{if $field.Tags}} {{$field.Tags}}{{end}}
	{{-end}}
}
`))

func main() {

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, os.Getenv("GOFILE"), nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	genLine, err := strconv.Atoi(os.Getenv("GOLINE"))
	if err != nil {
		log.Fatal("couldn't parse $GOLINE:", err)
	}

	var targetType string
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok != token.TYPE {
				return true
			}
			if fset.Position(x.Pos()).Line != genLine+1 {
				return true
			}
			for _, spec := range x.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					if _, ok := ts.Type.(*ast.StructType); !ok {
						log.Fatalf("%s is not a struct type", ts.Name.Name)
					}
					targetType = ts.Name.Name
					return false
				}
			}
		}
		return true
	})

	if targetType == "" {
		log.Fatal("no struct type found after //go:generate directive")
	}

	output, err := aggregateMetadata(node, targetType)
	if err != nil {
		log.Fatal("couldn't aggregate metadata:", err)
	}

	// todo: create output file
	// todo: pass output to template
	// todo: write output to file
}

func aggregateMetadata(node *ast.File, targetType string) (*GeneratorOutput, error) {
	var res *GeneratorOutput

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if x.Name.Name == targetType {
				if st, ok := x.Type.(*ast.StructType); ok {
					o := GeneratorOutput{
						PackageName: node.Name.Name,
						StructName:  targetType,
						Fields:      []Field{},
					}

					for _, field := range st.Fields.List {
						typeExpr := exprToString(field.Type)

						for _, name := range field.Names {
							f := Field{
								Name: name.Name,
								Type: typeExpr,
							}

							if field.Tag != nil {
								f.Tags = &field.Tag.Value
							}

							o.Fields = append(o.Fields, f)
						}
					}
					res = &o
				}
			}
		}
		return true
	})

	if res == nil {
		return nil, fmt.Errorf("could not aggregate metadata")
	}

	return res, nil
}

func exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return exprToString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + exprToString(t.Elt)
		}
		return fmt.Sprintf("[%s]%s", exprToString(t.Len), exprToString(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", exprToString(t.Key), exprToString(t.Value))
	default:
		return fmt.Sprintf("%#v", expr)
	}
}
