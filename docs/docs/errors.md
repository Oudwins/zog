---
sidebar_position: 6
toc_min_heading_level: 2
toc_max_heading_level: 4
---

# Errors

> Zod has Errors and Issues, issues are the structure thrown by Zod while Issues are the issues generated by the validation tests. In Zog we do not throw errors. But each issue may have an optional error inside it. If present this is the underlying error that caused the issue. For example the error generated trying to unmarshal json which is wrapped in a `z.Issue` to avoid exposing the underlying error to the user.

## Issues in Zog

In zog issues represent something that went wrong during any step of the [parsing execution structure](/core-concepts/parsing#parsing-execution-structure). Based on the schema you are using the returned issues will be in a different format:

###### ZogIssueList

**For Primitive Types**
Zog returns a list of `ZogIssue` instances.

```go
// will return []z.ZogIssue{z.ZogIssue{Message: "min length is 5"}, z.ZogIssue{Message: "invalid email"}}
errList := z.String().Min(5).Email().Parse("foo", &dest)
```

###### ZogIssueMap

**For Complex Types**
Zog returns a map of `ZogIssue` instances. Which uses the field path as the key & the list of issues as the value.

```go
// will return map[string][]z.ZogIssue{"name": []z.ZogIssue{z.ZogIssue{Message: "min length is 5"}}}
errMap := z.Struct(z.Schema{"name": z.String().Min(5)}).Parse(data, &dest)

// will return map[string][]z.ZogIssue{"$root": []z.ZogIssue{{Message: "slice length is not 2"}, "[0]": []z.ZogIssue{{Message: "min length is 10"}}}}
errsMap2 := z.Slice(z.String().Min(10)).Len(2).Parse([]string{"only_one"}, &dest)

// nested schemas will use the . or the [] notation to access the issues
errsMap3 := z.Struct(z.Schema{"name": z.String().Min(5), "address": z.Struct(z.Schema{"streets": z.Slice(z.String().Min(10))})}).Parse(data, &dest)
errsMap3["address.streets[0]"] // will return []z.ZogIssue{{Message: "min length is 10"}}
```

`$root` & `$first` are reserved keys for complex type validation, they are used for root level issues and for the first issue found in a schema, for example:

```go
errsMap := z.Slice(z.String()).Min(2).Parse([]string{"only_one"}, &dest)
errsMap["$root"]  // will return []z.ZogIssue{{Message: "slice length should at least be 2"}}
errsMap["$first"] // will return the same in this case []z.ZogIssue{{Message: "slice length should at least be 2"}}
```

You can also use the zconst package which contains constants for both of these keys

```go
const (
	// Key for a list of one ZogIssue that contains the first ZogIssue that occurred in a schema
	ISSUE_KEY_FIRST = "$first"
	// Key for a list of all ZogIssues that occurred in a schema at the root level for complex schemas. For example
	/*
			> Given this schema:
			z.Struct(....).TestFunc(func (v any, ctx z.Ctx) {
			   return false
			}, z.Message("test"))
			> And any input data. The output will contain:
			{
				"$root": [
					{
				     "message": "test"
					 restOfErrorFields..
					}
				]
			}
		    > This is also true for slices and even for pointers to primitive types.
	*/
	ISSUE_KEY_ROOT = "$root"
)
```

## Sanitizing ZogIssues

If you want to return issues to the user without the possibility of exposing internal confidential information, you can use the Zog sanitizer functions `z.Issues.SanitizeMap(ZogIssueMap)` or `z.Issues.SanitizeSlice(ZogIssueList)`. These functions will return a map or slice of strings of the issue messages (stripping out all the internal data from the issues like the error that caused the issue, the path, params, etc).

```go
errs := userSchema.Parse(data, &user)
// errs = map[string][]ZogIssue{"name": []ZogIssue{{Message: "min length is 5"}, {Message: "max length is 10"}}, "email": []ZogIssue{{Message: "is not a valid email"}}}
sanitized := z.Issues.SanitizeMap(errs)
// sanitized = {"name": []string{"min length is 5", "max length is 10"}, "email": []string{"is not a valid email"}}
```

## The ZogIssue

The `ZogIssue` is a struct that contains multiple fields and has some helper setter methods. It looks like this:

```go
// ZogIssue represents an issue that occurred during parsing or validation.
// When printed it looks like:
// ZogIssue{Code: coercion_issue, Params: map[], Type: number, Value: not_empty, Message: number is invalid, Error: failed to coerce string int: strconv.Atoi: parsing "not_empty": invalid syntax}
type ZogIssue struct {
	// Code is the unique identifier for the issue. Generally also the ID for the Test that caused the issue.
	Code zconst.ZogIssueCode
	// Path is the path to the field that caused the issue
	Path string
	// Value is the data value that caused the issue.
	// If using Schema.Parse(data, dest) then this will be the value of data.
	Value any
	// Dtype is the destination type. i.e The zconst.ZogType of the value that was validated.
	// If using Schema.Parse(data, dest) then this will be the type of dest.
	Dtype string
	// Params is the params map for the issue. Taken from the Test that caused the issue.
	// This may be nil if Test has no params.
	Params map[string]any
	// Message is the human readable, user-friendly message for the issue.
	// This is safe to expose to the user.
	Message string
	// Err is the wrapped error or nil if none
	Err error
}

// SetCode sets the issue code for the issue and returns the issue for chaining
func (i *ZogIssue) SetCode(c zconst.ZogIssueCode) *ZogIssue {
	i.Code = c
	return i
}

// SetPath sets the path for the issue and returns the issue for chaining
func (i *ZogIssue) SetPath(p string) *ZogIssue {
	i.Path = p
	return i
}

// SetValue sets the data value that caused the issue and returns the issue for chaining
func (i *ZogIssue) SetValue(v any) *ZogIssue {
	i.Value = v
	return i
}

// SetDType sets the destination type for the issue and returns the issue for chaining
func (i *ZogIssue) SetDType(t string) *ZogIssue {
	i.Dtype = t
	return i
}

// SetParams sets the params map for the issue and returns the issue for chaining
func (i *ZogIssue) SetParams(p map[string]any) *ZogIssue {
	i.Params = p
	return i
}

// SetMessage sets the human readable, user-friendly message for the issue and returns the issue for chaining
func (i *ZogIssue) SetMessage(m string) *ZogIssue {
	i.Message = m
	return i
}

// SetError sets the wrapped error for the issue and returns the issue for chaining
func (i *ZogIssue) SetError(e error) *ZogIssue {
	i.Err = e
	return i
}

// Unwrap returns the wrapped error or nil if none
func (i *ZogIssue) Unwrap() error {
	return i.Err
}

// Error returns the string representation of the ZogIssue (same as String())
func (i *ZogIssue) Error() string {
	return i.String()
}

// String returns the string representation of the ZogIssue (same as Error())
func (i *ZogIssue) String() string
```

## Error Codes

Error codes are unique identifiers for each type of issue that can occur in Zog. They are used to generate issue messages and to identify the issue in the issue formatter. A full updated list of issue codes can be found in the zconst package. But here are some common ones:

```go
type ZogIssueCode = string

const (
	IssueCodeCustom   ZogIssueCode = "custom"   // all
	IssueCodeRequired ZogIssueCode = "required" // all
	IssueCodeCoerce   ZogIssueCode = "coerce"   // all
	IssueCodeFallback ZogIssueCode = "fallback" // all. Applied when other errror code is not implemented. Required to be implemented for every zog type!

	IssueCodeEQ    ZogIssueCode = "eq"             // number, time, string
	IssueCodeOneOf ZogIssueCode = "one_of_options" // string or number

	IssueCodeMin      ZogIssueCode = "min"       // string, slice
	IssueCodeMax      ZogIssueCode = "max"       // string, slice
	IssueCodeLen      ZogIssueCode = "len"       // string, slice
	IssueCodeContains ZogIssueCode = "contained" // string, slice

	// number only
	IssueCodeLTE ZogIssueCode = "lte" // number
	IssueCodeLT  ZogIssueCode = "lt"  // number
	IssueCodeGTE ZogIssueCode = "gte" // number
	IssueCodeGT  ZogIssueCode = "gt"  // number

	// string only
	IssueCodeEmail           ZogIssueCode = "email"
	IssueCodeUUID            ZogIssueCode = "uuid"
	IssueCodeMatch           ZogIssueCode = "match"
	IssueCodeURL             ZogIssueCode = "url"
	IssueCodeHasPrefix       ZogIssueCode = "prefix"
	IssueCodeHasSuffix       ZogIssueCode = "suffix"
	IssueCodeContainsUpper   ZogIssueCode = "contains_upper"
	IssueCodeContainsLower   ZogIssueCode = "contains_lower"
	IssueCodeContainsDigit   ZogIssueCode = "contains_digit"
	IssueCodeContainsSpecial ZogIssueCode = "contains_special"
	// time only
	IssueCodeAfter  ZogIssueCode = "after"
	IssueCodeBefore ZogIssueCode = "before"
	// bool only
	IssueCodeTrue  ZogIssueCode = "true"
	IssueCodeFalse ZogIssueCode = "false"

	// ZHTTP ERRORS
	IssueCodeZHTTPInvalidJSON  ZogIssueCode = "invalid_json"  // invalid json body
	IssueCodeZHTTPInvalidForm  ZogIssueCode = "invalid_form"  // invalid form data
	IssueCodeZHTTPInvalidQuery ZogIssueCode = "invalid_query" // invalid query params
)
```

## Custom Error Messages

Zog has multiple ways of customizing issue messages as well as support for [i18n](/packages/i18n). Here is a list of the ways you can customize issue messages:

#### **1. Using the z.Message() function**

This is a function available for all tests, it allows you to set a custom message for the test.

```go
err := z.String().Min(5, z.Message("string must be at least 5 characters long")).Parse("bad", &dest)
// err = []ZogIssue{{Message: "string must be at least 5 characters long"}}
```

#### **2. Using the z.MessageFunc() function**

This is a function available for all tests, it allows you to set a custom message for the test.

This function takes in an `IssueFmtFunc` which is the function used to format issue messages in Zog. It has the following signature:

```go
type IssueFmtFunc = func(e *ZogIssue, ctx z.Ctx)
```

```go
err := z.String().Min(5, z.MessageFunc(func(e *z.ZogIssue, ctx z.Ctx) {
	e.SetMessage("string must be at least 5 characters long")
})).Parse("bad", &dest)
// err = []ZogIssue{{Message: "string must be at least 5 characters long"}}
```

#### **3. Using the WithIssueFormatter() ExecOption**

This allows you to set a custom `ZogIssue` formatter for the entire parsing operation. Beware you must handle all `ZogIssue` codes & types or you may get unexpected messages.

```go
err := z.String().Min(5).Email().Parse("zog", &dest, z.WithIssueFormatter(func(e *z.ZogIssue, ctx z.Ctx) {
	e.SetMessage("override message")
}))
// err = []ZogIssue{{Code: min_length_issue, Message: "override message"}, {Code: email_issue, Message: "override message"}}
```

See how our issue messages were overridden? Be careful when using this!

#### **4. Iterate over the returned issues and create custom messages**

```go
errs := userSchema.Parse(data, &user)
msgs := FormatZogIssues(errs)

func FormatZogIssues(errs z.ZogIssueMap) map[string][]string {
	// iterate over issues and create custom messages based on the issue code, the params and destination type
}
```

#### **5. Configure issue messages globally**

Zog provides a `conf` package where you can override the issue messages for specific issue codes. You will have to do a little digging to be able to do this. But here is an example:

```go
import (
	conf "github.com/Oudwins/zog/zconf"
	zconst "github.com/Oudwins/zog/zconst"
)

// override specific issue messages
// For this I recommend you import `zog/zconst` which contains zog constants but you can just use strings if you prefer
conf.DefaultIssueMessageMap[zconst.TypeString]["my_custom_issue_code"] = "my custom issue message"
conf.DefaultIssueMessageMap[zconst.TypeString][zconst.IssueCodeRequired] = "Now all required issues will get this message"
```

But you can also outright override the issue formatter and ignore the issues map completely:

```go
// override the issue formatter function - CAREFUL with this you can set every issue message to the same thing!
conf.IssueFormatter = func(e *p.ZogIssue, ctx z.Ctx) {
	// do something with the issue
	...
	// fallback to the default issue formatter
	conf.DefaultIssueFormatter(e, p) // this uses the DefaultErrMsgMap to format the issue messages
}
```

#### **6. Use the [i18n](/packages/i18n) package**

Really this only makes sense if you are doing i18n. Please please check out the [i18n](/packages/i18n) section for more information.
