---
sidebar_position: 6
toc_min_heading_level: 2
toc_max_heading_level: 4
---

# Errors

> Zod has Errors and Issues, issues are the structure thrown by Zod while Issues are the issues generated by the validation tests. In Zog we do not throw errors. But each issue may have an optional error inside it. If present this is the underlying error that caused the issue. For example the error generated trying to unmarshal json which is wrapped in a `z.Issue` to avoid exposing the underlying error to the user.

## Issues in Zog

In zog issues represent something that went wrong during any step of the [parsing execution structure](/core-concepts/parsing#parsing-execution-structure).

### ZogIssueList

All schemas return a `ZogIssueList`, which is a slice of `ZogIssue` instances:

```go
type ZogIssueList = []*ZogIssue
```

Each issue contains a `Path` field that indicates where in your data structure the issue occurred:

```go
// String schema - Path is empty for root-level primitive
errList := z.String().Min(5).Email().Parse("foo", &dest)
// errList[0].Path = "", errList[0].Message = "min length is 5"

// Struct schema - Path contains the field name
errList := z.Struct(z.Shape{"name": z.String().Min(5)}).Parse(data, &dest)
// errList[0].Path = "name", errList[0].Message = "min length is 5"

// Nested structs use dot notation
errList := z.Struct(z.Shape{
    "address": z.Struct(z.Shape{
        "streets": z.Slice(z.String().Min(10)),
    }),
}).Parse(data, &dest)
// errList[0].Path = "address.streets[0]", errList[0].Message = "min length is 10"
```

### Working with Issues

#### Getting the First Issue

```go
errs := schema.Parse(data, &dest)
if len(errs) > 0 {
    firstIssue := errs[0]
    // or use the helper:
    firstIssue := z.Issues.First(errs)
}
```

#### Getting Issues by Path

```go
errs := schema.Parse(data, &dest)
nameIssues := z.Issues.ForPath(errs, "name")
```

#### Grouping Issues by Path

If you need issues grouped by path (similar to the old map format):

```go
errs := schema.Parse(data, &dest)
issuesByPath := z.Issues.GroupByPath(errs)
// issuesByPath["name"] = []*ZogIssue{...}
```

### Special Paths

- Empty string `""` or `"$root"`: Issues at the root level of a complex schema (e.g., from schema-level tests)
- `"fieldName"`: Direct field issues
- `"parent.child"`: Nested field issues
- `"[0]"`, `"items[0]"`: Slice index issues

## Sanitizing ZogIssues

If you want to return issues to the user without the possibility of exposing internal confidential information, you can use the Zog sanitizer functions. These functions will return strings of the issue messages (stripping out all the internal data from the issues like the error that caused the issue, the path, params, etc).

### Sanitize to Slice

```go
errs := userSchema.Parse(data, &user)
// errs = []*ZogIssue{{Path: "name", Message: "min length is 5"}, {Path: "name", Message: "max length is 10"}, {Path: "email", Message: "is not a valid email"}}
sanitized := z.Issues.Sanitize(errs)
// sanitized = []string{"min length is 5", "max length is 10", "is not a valid email"}
```

### Sanitize by Path

If you prefer the grouped format:

```go
errs := userSchema.Parse(data, &user)
sanitizedByPath := z.Issues.SanitizeByPath(errs)
// sanitizedByPath = {"name": []string{"min length is 5", "max length is 10"}, "email": []string{"is not a valid email"}}
```

### Sanitize and Collect

To sanitize and return issues to the pool for reuse (for better performance):

```go
errs := userSchema.Parse(data, &user)
sanitized := z.Issues.SanitizeAndCollect(errs) // Issues are returned to pool
```

## The ZogIssue

The `ZogIssue` is a struct that contains multiple fields and has some helper setter methods. It looks like this:

```go
// ZogIssue represents an issue that occurred during parsing or validation.
// When printed it looks like:
// ZogIssue{Code: coercion_issue, Params: map[], Type: number, Value: not_empty, Message: number is invalid, Error: failed to coerce string int: strconv.Atoi: parsing "not_empty": invalid syntax}
type ZogIssue struct {
	// Code is the unique identifier for the issue. Generally also the ID for the Test that caused the issue.
	Code zconst.ZogIssueCode
	// Path is the path to the field that caused the issue
	Path string
	// Value is the data value that caused the issue.
	// If using Schema.Parse(data, dest) then this will be the value of data.
	Value any
	// Dtype is the destination type. i.e The zconst.ZogType of the value that was validated.
	// If using Schema.Parse(data, dest) then this will be the type of dest.
	Dtype string
	// Params is the params map for the issue. Taken from the Test that caused the issue.
	// This may be nil if Test has no params.
	Params map[string]any
	// Message is the human readable, user-friendly message for the issue.
	// This is safe to expose to the user.
	Message string
	// Err is the wrapped error or nil if none
	Err error
}

// SetCode sets the issue code for the issue and returns the issue for chaining
func (i *ZogIssue) SetCode(c zconst.ZogIssueCode) *ZogIssue {
	i.Code = c
	return i
}

// SetPath sets the path for the issue and returns the issue for chaining
func (i *ZogIssue) SetPath(p string) *ZogIssue {
	i.Path = p
	return i
}

// SetValue sets the data value that caused the issue and returns the issue for chaining
func (i *ZogIssue) SetValue(v any) *ZogIssue {
	i.Value = v
	return i
}

// SetDType sets the destination type for the issue and returns the issue for chaining
func (i *ZogIssue) SetDType(t string) *ZogIssue {
	i.Dtype = t
	return i
}

// SetParams sets the params map for the issue and returns the issue for chaining
func (i *ZogIssue) SetParams(p map[string]any) *ZogIssue {
	i.Params = p
	return i
}

// SetMessage sets the human readable, user-friendly message for the issue and returns the issue for chaining
func (i *ZogIssue) SetMessage(m string) *ZogIssue {
	i.Message = m
	return i
}

// SetError sets the wrapped error for the issue and returns the issue for chaining
func (i *ZogIssue) SetError(e error) *ZogIssue {
	i.Err = e
	return i
}

// Unwrap returns the wrapped error or nil if none
func (i *ZogIssue) Unwrap() error {
	return i.Err
}

// Error returns the string representation of the ZogIssue (same as String())
func (i *ZogIssue) Error() string {
	return i.String()
}

// String returns the string representation of the ZogIssue (same as Error())
func (i *ZogIssue) String() string
```

## Error Codes

Error codes are unique identifiers for each type of issue that can occur in Zog. They are used to generate issue messages and to identify the issue in the issue formatter. A full updated list of issue codes can be found in the zconst package. But here are some common ones:

```go
type ZogIssueCode = string

const (
	IssueCodeCustom   ZogIssueCode = "custom"   // all
	IssueCodeRequired ZogIssueCode = "required" // all
	IssueCodeCoerce   ZogIssueCode = "coerce"   // all
	IssueCodeFallback ZogIssueCode = "fallback" // all. Applied when other errror code is not implemented. Required to be implemented for every zog type!

	IssueCodeEQ    ZogIssueCode = "eq"             // number, time, string
	IssueCodeOneOf ZogIssueCode = "one_of_options" // string or number

	IssueCodeMin      ZogIssueCode = "min"       // string, slice
	IssueCodeMax      ZogIssueCode = "max"       // string, slice
	IssueCodeLen      ZogIssueCode = "len"       // string, slice
	IssueCodeContains ZogIssueCode = "contained" // string, slice

	// number only
	IssueCodeLTE ZogIssueCode = "lte" // number
	IssueCodeLT  ZogIssueCode = "lt"  // number
	IssueCodeGTE ZogIssueCode = "gte" // number
	IssueCodeGT  ZogIssueCode = "gt"  // number

	// string only
	IssueCodeEmail           ZogIssueCode = "email"
	IssueCodeUUID            ZogIssueCode = "uuid"
	IssueCodeMatch           ZogIssueCode = "match"
	IssueCodeURL             ZogIssueCode = "url"
	IssueCodeHasPrefix       ZogIssueCode = "prefix"
	IssueCodeHasSuffix       ZogIssueCode = "suffix"
	IssueCodeContainsUpper   ZogIssueCode = "contains_upper"
	IssueCodeContainsLower   ZogIssueCode = "contains_lower"
	IssueCodeContainsDigit   ZogIssueCode = "contains_digit"
	IssueCodeContainsSpecial ZogIssueCode = "contains_special"
	// time only
	IssueCodeAfter  ZogIssueCode = "after"
	IssueCodeBefore ZogIssueCode = "before"
	// bool only
	IssueCodeTrue  ZogIssueCode = "true"
	IssueCodeFalse ZogIssueCode = "false"

	// ZHTTP ERRORS
	IssueCodeZHTTPInvalidJSON  ZogIssueCode = "invalid_json"  // invalid json body
	IssueCodeZHTTPInvalidForm  ZogIssueCode = "invalid_form"  // invalid form data
	IssueCodeZHTTPInvalidQuery ZogIssueCode = "invalid_query" // invalid query params
)
```

## Custom Error Messages

Zog has multiple ways of customizing issue messages as well as support for [i18n](/packages/i18n). Here is a list of the ways you can customize issue messages:

#### **1. Using the z.Message() function**

This is a function available for all tests, it allows you to set a custom message for the test.

```go
err := z.String().Min(5, z.Message("string must be at least 5 characters long")).Parse("bad", &dest)
// err = []ZogIssue{{Message: "string must be at least 5 characters long"}}
```

#### **2. Using the z.MessageFunc() function**

This is a function available for all tests, it allows you to set a custom message for the test.

This function takes in an `IssueFmtFunc` which is the function used to format issue messages in Zog. It has the following signature:

```go
type IssueFmtFunc = func(e *ZogIssue, ctx z.Ctx)
```

```go
err := z.String().Min(5, z.MessageFunc(func(e *z.ZogIssue, ctx z.Ctx) {
	e.SetMessage("string must be at least 5 characters long")
})).Parse("bad", &dest)
// err = []ZogIssue{{Message: "string must be at least 5 characters long"}}
```

#### **3. Using the WithIssueFormatter() ExecOption**

This allows you to set a custom `ZogIssue` formatter for the entire parsing operation. Beware you must handle all `ZogIssue` codes & types or you may get unexpected messages.

```go
err := z.String().Min(5).Email().Parse("zog", &dest, z.WithIssueFormatter(func(e *z.ZogIssue, ctx z.Ctx) {
	e.SetMessage("override message")
}))
// err = []ZogIssue{{Code: min_length_issue, Message: "override message"}, {Code: email_issue, Message: "override message"}}
```

See how our issue messages were overridden? Be careful when using this!

#### **4. Iterate over the returned issues and create custom messages**

```go
errs := userSchema.Parse(data, &user)
msgs := FormatZogIssues(errs)

func FormatZogIssues(errs z.ZogIssueList) map[string][]string {
	// iterate over issues and create custom messages based on the issue code, the params and destination type
	result := make(map[string][]string)
	for _, issue := range errs {
		path := issue.Path
		if path == "" {
			path = "$root"
		}
		result[path] = append(result[path], issue.Message)
	}
	return result
}
```

#### **5. Configure issue messages globally**

Zog provides a `conf` package where you can override the issue messages for specific issue codes. You will have to do a little digging to be able to do this. But here is an example:

```go
import (
	conf "github.com/Oudwins/zog/zconf"
	zconst "github.com/Oudwins/zog/zconst"
)

// override specific issue messages
// For this I recommend you import `zog/zconst` which contains zog constants but you can just use strings if you prefer
conf.DefaultIssueMessageMap[zconst.TypeString]["my_custom_issue_code"] = "my custom issue message"
conf.DefaultIssueMessageMap[zconst.TypeString][zconst.IssueCodeRequired] = "Now all required issues will get this message"
```

But you can also outright override the issue formatter and ignore the issues map completely:

```go
// override the issue formatter function - CAREFUL with this you can set every issue message to the same thing!
conf.IssueFormatter = func(e *p.ZogIssue, ctx z.Ctx) {
	// do something with the issue
	...
	// fallback to the default issue formatter
	conf.DefaultIssueFormatter(e, p) // this uses the DefaultErrMsgMap to format the issue messages
}
```

#### **6. Use the [i18n](/packages/i18n) package**

Really this only makes sense if you are doing i18n. Please please check out the [i18n](/packages/i18n) section for more information.

---

## Migrating from ZogIssueMap

If you're upgrading from a version that returned `ZogIssueMap` for complex schemas:

### Before (v0.x)

```go
errs := userSchema.Parse(data, &user)
if errs != nil {
    // Check specific field
    if nameErrs, ok := errs["name"]; ok {
        for _, e := range nameErrs {
            fmt.Println(e.Message)
        }
    }
    // Get first error
    first := errs["$first"][0]
}
```

### After (v1.x)

```go
errs := userSchema.Parse(data, &user)
if len(errs) > 0 {
    // Check specific field
    nameErrs := z.Issues.ForPath(errs, "name")
    for _, e := range nameErrs {
        fmt.Println(e.Message)
    }
    // Get first error
    first := z.Issues.First(errs)
}
```

### Using the Compatibility Helper

If you have a lot of code to migrate, you can use the grouping helper:

```go
errs := userSchema.Parse(data, &user)
// Convert to map format for compatibility
errsMap := z.Issues.GroupByPath(errs)
if errsMap != nil {
    // Use like before
    if nameErrs, ok := errsMap["name"]; ok {
        // ...
    }
}
```
